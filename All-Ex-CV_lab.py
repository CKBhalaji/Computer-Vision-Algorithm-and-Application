# -*- coding: utf-8 -*-
"""CV-Lab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18VUDqn-BXDW8qEfBbm90bzbZkpkdFQh-

Ex-1

1.1.Read Write and Save the image
"""

import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow  # For displaying images in Colab
from google.colab import files  # For uploading and downloading files

# Prompt the user to upload an image
uploaded = files.upload()

# Check if any files were uploaded
if len(uploaded) == 0:
    print("No files were uploaded.")
else:
    # Get the first uploaded file (assuming only one file is uploaded)
    image_filename = list(uploaded.keys())[0]

    # Read the uploaded image using OpenCV
    image = cv2.imread(image_filename)

    # Check if the image was read successfully
    if image is None:
        print('Error: Could not open or read your image.')
    else:
        # Save the image with a different name
        output_filename = 'output_image.jpg'
        cv2.imwrite(output_filename, image)

        # Get the aspect ratio of the image
        height, width, _ = image.shape
        aspect_ratio = width / height

        # Display the original uploaded image with aspect ratio maintained outside
        plt.figure(figsize=(10 * aspect_ratio, 10))
        plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        plt.title('Original Image')
        plt.axis('off')  # Turn off axis labels
        plt.show()

        # Check if the image was saved successfully
        saved_image = cv2.imread(output_filename)
        if saved_image is not None:
            print('Your image has been saved successfully as "output_image.jpg".')
        else:
            print('Error: Could not save your image.')

"""1.2.Convert Image into Gray Scale"""

import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow  # For displaying images in Colab
from google.colab import files  # For uploading and downloading files

# Prompt the user to upload an image
uploaded = files.upload()

# Check if any files were uploaded
if len(uploaded) == 0:
    print("No files were uploaded.")
else:
    # Get the first uploaded file (assuming only one file is uploaded)
    image_filename = list(uploaded.keys())[0]

    # Read the uploaded image using OpenCV
    original_image = cv2.imread(image_filename)

    # Check if the image was read successfully
    if original_image is None:
        print('Error: Could not open or read your image.')
    else:
        # Convert the image to grayscale
        gray_image = cv2.cvtColor(original_image, cv2.COLOR_BGR2GRAY)

        # Display the original and grayscale images
        plt.figure(figsize=(10, 5))

        # Original Image
        plt.subplot(1, 2, 1)
        plt.imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
        plt.title('Original Image')

        # Grayscale Image
        plt.subplot(1, 2, 2)
        plt.imshow(gray_image, cmap='gray')
        plt.title('Grayscale Image')

        plt.show()

"""1.3.Image Enhancement"""

import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow  # For displaying images in Colab
from google.colab import files  # For uploading and downloading files

# Prompt the user to upload an image
uploaded = files.upload()

# Check if any files were uploaded
if len(uploaded) == 0:
    print("No files were uploaded.")
else:
    # Get the first uploaded file (assuming only one file is uploaded)
    image_filename = list(uploaded.keys())[0]

    # Read the uploaded image using OpenCV
    original_image = cv2.imread(image_filename)

    # Check if the image was read successfully
    if original_image is None:
        print('Error: Could not open or read your image.')
    else:
        # Brighten the image
        brightness_factor = 2.5
        brightened_image = cv2.convertScaleAbs(original_image, alpha=brightness_factor, beta=0)

        # Display the original, brightened, and enhanced grayscale images
        plt.figure(figsize=(12, 4))

        # Original Image
        plt.subplot(1, 3, 1)
        plt.imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
        plt.title('Original Image')

        # Brightened Image
        plt.subplot(1, 3, 2)
        plt.imshow(cv2.cvtColor(brightened_image, cv2.COLOR_BGR2RGB))
        plt.title('Brightened Image')

        # Enhanced Grayscale Image
        enhanced_image = cv2.equalizeHist(cv2.cvtColor(original_image, cv2.COLOR_BGR2GRAY))
        plt.subplot(1, 3, 3)
        plt.imshow(enhanced_image, cmap='gray')
        plt.title('Enhanced Image')

        plt.show()

"""1.4.Image Resizing"""

import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow  # For displaying images in Colab
from google.colab import files  # For uploading and downloading files

# Prompt the user to upload an image
uploaded = files.upload()

# Check if any files were uploaded
if len(uploaded) == 0:
    print("No files were uploaded.")
else:
    # Get the first uploaded file (assuming only one file is uploaded)
    image_filename = list(uploaded.keys())[0]

    # Read the uploaded image using OpenCV
    original_image = cv2.imread(image_filename)

    # Check if the image was read successfully
    if original_image is None:
        print('Error: Could not open or read your image.')
    else:
        # Prompt the user for the desired width and height
        new_width = int(input("Enter the desired width for resizing: "))
        new_height = int(input("Enter the desired height for resizing: "))

        # Resize the image using OpenCV's resize function
        resized_image = cv2.resize(original_image, (new_width, new_height))

        # Display the original and resized images
        plt.figure(figsize=(10, 5))

        # Original Image
        plt.subplot(1, 2, 1)
        plt.imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
        plt.title('Original Image')

        # Resized Image
        plt.subplot(1, 2, 2)
        plt.imshow(cv2.cvtColor(resized_image, cv2.COLOR_BGR2RGB))
        plt.title('Resized Image')

        plt.show()

"""1.5.Negative Image"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow  # For displaying images in Colab
from google.colab import files  # For uploading and downloading files

# Prompt the user to upload an image
uploaded = files.upload()

# Check if any files were uploaded
if len(uploaded) == 0:
    print("No files were uploaded.")
else:
    # Get the first uploaded file (assuming only one file is uploaded)
    image_filename = list(uploaded.keys())[0]

    # Read the uploaded image using OpenCV
    original_image = cv2.imread(image_filename)

    # Check if the image was read successfully
    if original_image is None:
        print('Error: Could not open or read your image.')
    else:
        # Create the negative of the image
        negative_image = 255 - original_image

        # Display the original and negative images
        plt.figure(figsize=(10, 5))

        # Original Image
        plt.subplot(1, 2, 1)
        plt.imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
        plt.title('Original Image')

        # Negative Image
        plt.subplot(1, 2, 2)
        plt.imshow(cv2.cvtColor(negative_image, cv2.COLOR_BGR2RGB))
        plt.title('Negative Image')

        plt.show()

"""1.6.Histogram Equalization"""

import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow  # For displaying images in Colab
from google.colab import files  # For uploading and downloading files

# Prompt the user to upload an image
uploaded = files.upload()

# Check if any files were uploaded
if len(uploaded) == 0:
    print("No files were uploaded.")
else:
    # Get the first uploaded file (assuming only one file is uploaded)
    image_filename = list(uploaded.keys())[0]

    # Read the uploaded image using OpenCV
    img_bgr = cv2.imread(image_filename, 1)

    # Check if the image was read successfully
    if img_bgr is None:
        print('Error: Could not open or read your image.')
    else:
        # Create a subplot with two panels (original image and histogram)
        fig, axs = plt.subplots(1, 2, figsize=(12, 4))

        # Display the original image
        axs[0].imshow(cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB))
        axs[0].set_title('Original Image')

        # Calculate and plot the histogram
        color = ('b', 'g', 'r')
        for i, col in enumerate(color):
            histr = cv2.calcHist([img_bgr], [i], None, [256], [0, 256])
            axs[1].plot(histr, color=col)

        axs[1].set_title('Histogram')
        axs[1].set_xlim([0, 256])

        plt.show()

"""HISTOGRAM FOR ORIGINAL IMAGE AND EQUALIZED IMAGE (Gray Scale)"""

import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow  # For displaying images in Colab
from google.colab import files  # For uploading and downloading files

# Prompt the user to upload an image
uploaded = files.upload()

# Check if any files were uploaded
if len(uploaded) == 0:
    print("No files were uploaded.")
else:
    # Get the first uploaded file (assuming only one file is uploaded)
    image_filename = list(uploaded.keys())[0]

    # Read the uploaded image using OpenCV in grayscale mode
    image = cv2.imread(image_filename, cv2.IMREAD_GRAYSCALE)

    # Check if the image was read successfully
    if image is None:
        print('Error: Could not open or read your image.')
    else:
        # Perform histogram equalization
        equalized_image = cv2.equalizeHist(image)

        # Create subplots for displaying images and histograms
        fig, axs = plt.subplots(2, 2, figsize=(12, 8))

        # Display the original grayscale image
        axs[0, 0].imshow(image, cmap='gray')
        axs[0, 0].set_title('Original Image')

        # Plot the histogram of the original image
        axs[0, 1].hist(image.ravel(), bins=256, range=(0, 256), density=True, color='gray')
        axs[0, 1].set_title('Histogram of Original Image')
        axs[0, 1].set_xlim([0, 256])

        # Display the equalized grayscale image
        axs[1, 0].imshow(equalized_image, cmap='gray')
        axs[1, 0].set_title('Equalized Image')

        # Plot the histogram of the equalized image
        axs[1, 1].hist(equalized_image.ravel(), bins=256, range=(0, 256), density=True, color='gray')
        axs[1, 1].set_title('Histogram of Equalized Image')
        axs[1, 1].set_xlim([0, 256])

        plt.tight_layout()
        plt.show()

"""1.7.Addition and subtraction of a image"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow  # For displaying images in Colab
from google.colab import files  # For uploading and downloading files

# Prompt the user to upload the first image
uploaded1 = files.upload()

# Check if any files were uploaded
if len(uploaded1) == 0:
    print("No files were uploaded for Image 1.")
else:
    # Get the filename of the first uploaded image
    image_filename1 = list(uploaded1.keys())[0]

    # Read the first uploaded image using OpenCV
    image1 = cv2.imread(image_filename1)

    # Prompt the user to upload the second image
    uploaded2 = files.upload()

    # Check if any files were uploaded for Image 2
    if len(uploaded2) == 0:
        print("No files were uploaded for Image 2.")
    else:
        # Get the filename of the second uploaded image
        image_filename2 = list(uploaded2.keys())[0]

        # Read the second uploaded image using OpenCV
        image2 = cv2.imread(image_filename2)

        # Check if the images have the same dimensions
        if image1.shape != image2.shape:
            raise ValueError("Both images should be in the same dimensions")

        # Perform addition and subtraction of the images
        addition_result = cv2.add(image1, image2)
        subtraction_result = cv2.subtract(image1, image2)

        # Create subplots to display the images and results
        plt.figure(figsize=(12, 4))
        plt.subplot(1, 4, 1)
        plt.imshow(cv2.cvtColor(image1, cv2.COLOR_BGR2RGB))
        plt.title('Image 1')
        plt.subplot(1, 4, 2)
        plt.imshow(cv2.cvtColor(image2, cv2.COLOR_BGR2RGB))
        plt.title('Image 2')
        plt.subplot(1, 4, 3)
        plt.imshow(cv2.cvtColor(addition_result, cv2.COLOR_BGR2RGB))
        plt.title('Addition Result')
        plt.subplot(1, 4, 4)
        plt.imshow(cv2.cvtColor(subtraction_result, cv2.COLOR_BGR2RGB))
        plt.title('Subtraction Result')
        plt.show()

"""**EX-2**ADDING AND REMOVAL OF NOISE

1.ADDING AND REMOVAL OF NOISE
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
from google.colab import files  # Import the 'files' module for Colab

# Upload the image from your computer
uploaded = files.upload()
image_filename = list(uploaded.keys())[0]

# Read the uploaded image in color
img_color = cv2.imread(image_filename)

# Convert the color image to grayscale for processing
img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)

# Adding Gaussian noise
gauss_noise = np.zeros_like(img_gray, dtype=np.uint8)
cv2.randn(gauss_noise, 128, 20)
gauss_noise = (gauss_noise * 0.5).astype(np.uint8)
gn_img = cv2.add(img_gray, gauss_noise)

# Convert the noise to color for display
gauss_noise_color = cv2.cvtColor(gauss_noise, cv2.COLOR_GRAY2BGR)

# Display images for Gaussian noise
fig = plt.figure(dpi=300)
fig.add_subplot(1, 3, 1)
plt.imshow(cv2.cvtColor(img_color, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Original")

fig.add_subplot(1, 3, 2)
plt.imshow(cv2.cvtColor(gauss_noise_color, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Gaussian Noise")

fig.add_subplot(1, 3, 3)
plt.imshow(cv2.cvtColor(gn_img, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Combined")

plt.show()

# Reset variables for the next noise type
img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)

# Adding Impulse noise
imp_noise = np.zeros_like(img_gray, dtype=np.uint8)
cv2.randu(imp_noise, 0, 255)
imp_noise = cv2.threshold(imp_noise, 245, 255, cv2.THRESH_BINARY)[1]
in_img = cv2.add(img_gray, imp_noise)

# Convert the noise to color for display
imp_noise_color = cv2.cvtColor(imp_noise, cv2.COLOR_GRAY2BGR)

# Display images for Impulse noise
fig = plt.figure(dpi=300)
fig.add_subplot(1, 3, 1)
plt.imshow(cv2.cvtColor(img_color, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Original")

fig.add_subplot(1, 3, 2)
plt.imshow(cv2.cvtColor(imp_noise_color, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Impulse Noise")

fig.add_subplot(1, 3, 3)
plt.imshow(cv2.cvtColor(in_img, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Combined")

plt.show()

# Reset variables for the next noise type
img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)

# Adding Uniform noise
uni_noise = np.zeros_like(img_gray, dtype=np.uint8)
cv2.randu(uni_noise, 0, 255)
uni_noise = (uni_noise * 0.5).astype(np.uint8)
un_img = cv2.add(img_gray, uni_noise)

# Convert the noise to color for display
uni_noise_color = cv2.cvtColor(uni_noise, cv2.COLOR_GRAY2BGR)

# Display images for Uniform noise
fig = plt.figure(dpi=300)
fig.add_subplot(1, 3, 1)
plt.imshow(cv2.cvtColor(img_color, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Original")

fig.add_subplot(1, 3, 2)
plt.imshow(cv2.cvtColor(uni_noise_color, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Uniform Noise")

fig.add_subplot(1, 3, 3)
plt.imshow(cv2.cvtColor(un_img, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Combined")

plt.show()

# Reset variables for the next filter type
img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)

# Applying Median filters
blurred1 = cv2.medianBlur(gn_img, 3)
blurred2 = cv2.medianBlur(un_img, 3)
blurred3 = cv2.medianBlur(in_img, 3)

# Display images for Median filters
fig = plt.figure(dpi=300)
fig.add_subplot(1, 3, 1)
plt.imshow(cv2.cvtColor(blurred1, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Median Gaussian")

fig.add_subplot(1, 3, 2)
plt.imshow(cv2.cvtColor(blurred2, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Median Uniform")

fig.add_subplot(1, 3, 3)
plt.imshow(cv2.cvtColor(blurred3, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Median Impulse")

plt.show()

# Applying Average filter
img_new = cv2.blur(gn_img, (3, 3))

# Display images for Average filter
fig = plt.figure(dpi=300)
fig.add_subplot(1, 2, 1)
plt.imshow(cv2.cvtColor(gn_img, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Original")
fig.add_subplot(1, 2, 2)
plt.imshow(cv2.cvtColor(img_new, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.title("Average Filter")
plt.show()

"""**Ex-3**

1.EDGE DETECTION
I) Canny edge detection
II) Sobel edge detection
III) Prewitt edge detection
"""

#EDGE DETECTION
import cv2
import numpy as np
import matplotlib.pyplot as plt
# Upload the image from your computer
uploaded = files.upload()
image_filename = list(uploaded.keys())[0]

# Read the uploaded image in color
image = cv2.imread(image_filename)
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Convert the RGB image to grayscale
image_gray = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)

# Sobel Edge Detection
sobel_x = cv2.Sobel(image_gray, cv2.CV_64F, 1, 0, ksize=3)
sobel_y = cv2.Sobel(image_gray, cv2.CV_64F, 0, 1, ksize=3)
sobel_edges = np.sqrt(sobel_x**2 + sobel_y**2)

# Prewitt Edge Detection
prewitt_kernel_x = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]])
prewitt_kernel_y = np.array([[-1, -1, -1], [0, 0, 0], [1, 1, 1]])
prewitt_x = cv2.filter2D(image_gray, cv2.CV_64F, prewitt_kernel_x)
prewitt_y = cv2.filter2D(image_gray, cv2.CV_64F, prewitt_kernel_y)
prewitt_edges = np.sqrt(prewitt_x**2 + prewitt_y**2)

# Roberts Edge Detection
roberts_kernel_x = np.array([[1, 0], [0, -1]])
roberts_kernel_y = np.array([[0, 1], [-1, 0]])
roberts_x = cv2.filter2D(image_gray, cv2.CV_64F, roberts_kernel_x)
roberts_y = cv2.filter2D(image_gray, cv2.CV_64F, roberts_kernel_y)
roberts_edges = np.sqrt(roberts_x**2 + roberts_y**2)

# Canny Edge Detection
canny_edges = cv2.Canny(image_gray, 50, 150)

# Display the results
plt.figure(figsize=(10, 6))

plt.subplot(231), plt.imshow(image_rgb), plt.title('Original (RGB)')
plt.subplot(232), plt.imshow(sobel_edges, cmap='gray'), plt.title('Sobel')
plt.subplot(233), plt.imshow(prewitt_edges, cmap='gray'), plt.title('Prewitt')
plt.subplot(234), plt.imshow(roberts_edges, cmap='gray'), plt.title('Roberts')
plt.subplot(235), plt.imshow(canny_edges, cmap='gray'), plt.title('Canny')

plt.show()

"""**Ex-4**

Perform morphological operations on an image
i.	Dilation
ii.	Erosion
iii.	Closing
iv.	Opening

Erotion and Dialation
"""

import matplotlib.pyplot as plt
def erosion(image, se):
    m, n = len(image), len(image[0])
    result = [[0 for _ in range(n)] for _ in range(m)]
    for i in range(1, m - 1):
        for j in range(1, n - 1):
            min_val = 255
            for k in range(-1, 2):
                for l in range(-1, 2):
                    if se[k + 1][l + 1] == 255:
                        min_val = min(min_val, image[i + k][j + l])
            result[i][j] = min_val
    return result
def dilation(image, se):
    m, n = len(image), len(image[0])
    result = [[0 for _ in range(n)] for _ in range(m)]
    for i in range(1, m - 1):
        for j in range(1, n - 1):
            max_val = 0
            for k in range(-1, 2):
                for l in range(-1, 2):
                    if se[k + 1][l + 1] == 255:
                        max_val = max(max_val, image[i + k][j + l])
            result[i][j] = max_val
    return result
image = [
    [0, 0, 0, 0, 0, 0, 0],
    [0, 255, 0, 255, 0, 255, 0],
    [0, 0, 255, 255, 255, 0, 0],
    [0, 255, 0, 255, 0, 255, 0],
    [0, 0, 255, 255, 255, 0, 0],
    [0, 255, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0]
]
se = [
    [0, 255, 0],
    [255, 255, 255],
    [0, 255, 0]
]
eroded_image = erosion(image, se)
dilated_image = dilation(image, se)
fig = plt.figure(dpi=300)
fig.add_subplot(2, 2, 1)
plt.imshow(image, cmap='gray')
plt.axis("off")
plt.title("Original Image")
fig.add_subplot(2, 2, 2)
plt.imshow(se, cmap='gray')
plt.axis("off")
plt.title("Structuring Element")
fig.add_subplot(2, 2, 3)
plt.imshow(eroded_image, cmap='gray')
plt.axis("off")
plt.title("Eroded Image")
fig.add_subplot(2, 2, 4)
plt.imshow(dilated_image, cmap='gray')
plt.axis("off")
plt.title("Dilated Image")
plt.show()

"""Opening and Closing"""

import matplotlib.pyplot as plt
def opening(image, se):
    eroded = erosion(image, se)
    opened = dilation(eroded, se)
    return opened
def closing(image, se):
    dilated = dilation(image, se)
    closed = erosion(dilated, se)
    return closed
image = [
    [0, 0, 0, 0, 0, 0, 0],
    [0, 255, 0, 255, 0, 255, 0],
    [0, 0, 255, 255, 255, 0, 0],
    [0, 255, 0, 255, 0, 255, 0],
    [0, 0, 255, 255, 255, 0, 0],
    [0, 255, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0]
]
se = [
    [0, 255, 0],
    [255, 255, 255],
    [0, 255, 0]
]
opened_image = opening(image, se)
closed_image = closing(image, se)
fig = plt.figure(dpi=300)
fig.add_subplot(2, 2, 1)
plt.imshow(image, cmap='gray')
plt.axis("off")
plt.title("Original Image")
fig.add_subplot(2, 2, 2)
plt.imshow(se, cmap='gray')
plt.axis("off")
plt.title("Structuring Element")
fig.add_subplot(2, 2, 3)
plt.imshow(opened_image, cmap='gray')
plt.axis("off")
plt.title("Opened Image")
fig.add_subplot(2, 2, 4)
plt.imshow(closed_image, cmap='gray')
plt.axis("off")
plt.title("Closed Image")
plt.show()

"""BOUNDARY EXTRACTION"""

import numpy as np
# Original image and structuring element
image = [
    [0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 0],
    [0, 255, 255, 255, 255, 255, 0],
    [0, 255, 255, 255, 255, 255, 0],
    [0, 255, 255, 255, 255, 255, 0],
    [0, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0]
]
se = [
    [0, 255, 0],
    [255, 255, 255],
    [0, 255, 0]
]

# Compute erosion
eroded_image = erosion(image, se)
# Compute boundary by subtracting eroded image from original image
boundary_image = np.subtract(image, eroded_image)
# Display the boundary image
fig = plt.figure(dpi=300)
fig.add_subplot(1, 3, 1)
plt.imshow(image, cmap='gray')
plt.axis("off")
plt.title("Original Image")
fig.add_subplot(1, 3, 2)
plt.imshow(se, cmap='gray')
plt.axis("off")
plt.title("Structuring Element")
fig.add_subplot(1, 3, 3)
plt.imshow(boundary_image, cmap='gray')
plt.axis("off")
plt.title("Boundary Image")
plt.show()

"""Ex-5-Detect Lines In An Image Using Hough Transform"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files

# Upload image
uploaded = files.upload()
image_filename = list(uploaded.keys())[0]

# Read uploaded image
image = cv2.imread(image_filename)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
fig = plt.figure(dpi=300)
fig.add_subplot(1, 2, 1)
plt.imshow(image)
plt.axis("off")
plt.title('Original Image')

# Load image in grayscale
img = cv2.imread(image_filename, 0)

# Check if the image is loaded successfully
if img is None:
    print("Error: Unable to load the image.")
else:
    # Get image dimensions
    y, x = img.shape

    # Use canny edge detection
    edges = cv2.Canny(img, x, y, apertureSize=3)

    # Apply HoughLinesP method to directly obtain line end points
    lines_list = []
    lines = cv2.HoughLinesP(
        edges,  # Input edge image
        1,  # Distance resolution in pixels
        np.pi / 180,  # Angle resolution in radians
        threshold=40,  # Min number of votes for valid line
        minLineLength=5,  # Min allowed length of line
        maxLineGap=10  # Max allowed gap between line for joining them
    )

    # Check if lines are detected
    if lines is not None:
        # Iterate over points
        for points in lines:
            # Extracted points nested in the list
            x1, y1, x2, y2 = points[0]
            # Draw the lines joining the points
            # On the original image
            cv2.line(image, (x1, y1), (x2, y2), (0, 255, 0), 2)
            # Maintain a simple lookup list for points
            lines_list.append([(x1, y1), (x2, y2)])

        fig.add_subplot(1, 2, 2)
        plt.imshow(image)
        plt.axis("off")
        plt.title('Detected Lines')
        plt.show()
    else:
        print("No lines detected.")

"""Ex. No.:06	        Image Segmentation with Watershed"""

#IMAGE SEGMENTATION WITH WATERSHED ALGORITHM
import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
# Upload image
uploaded = files.upload()
image_filename = list(uploaded.keys())[0]

# Read uploaded image
image = cv2.imread(image_filename)
# Convert the image to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
image=cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
fig=plt.figure(dpi=300)
fig.add_subplot(3,3,1)
plt.imshow(image)
plt.axis("off")
plt.title('Original Image')

ret, threshold = cv2.threshold(gray, 0, 255,  cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
# Perform morphological opening to remove noise
kernel = np.ones((3, 3), np.uint8)
opening = cv2.morphologyEx(threshold, cv2.MORPH_OPEN, kernel, iterations=2)
# Find background region
sure_bg = cv2.dilate(opening, kernel, iterations=3)
# Find foreground region
dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
ret, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)
# Create marker image
sure_fg = np.uint8(sure_fg)
unknown = cv2.subtract(sure_bg, sure_fg)
# Apply Watershed algorithm
ret, markers = cv2.connectedComponents(sure_fg)
markers = markers + 1
markers[unknown == 255] = 0
cv2.watershed(image, markers)
# Apply colormap to the markers
colored_markers = np.zeros_like(image)
colored_markers[markers == -1] = [255, 0, 0]  # Boundaries in blue color
# Display the segmented image
segmented_image = cv2.addWeighted(image, 0.7, colored_markers, 0.3, 0)

fig.add_subplot(3,3,2)
plt.imshow(sure_bg)
plt.axis("off")
plt.title('Sure Background')

fig.add_subplot(3,3,3)
plt.imshow(dist_transform)
plt.axis("off")
plt.title('Distance Transform')
fig.add_subplot(3,3,4)

plt.imshow(sure_fg)
plt.axis("off")
plt.title('Sure Background')
fig.add_subplot(3,3,5)

plt.imshow(unknown)
plt.axis("off")
plt.title('Unknown')
fig.add_subplot(3,3,6)

plt.imshow(sure_bg)
plt.axis("off")
plt.title('Sure Background')
fig.add_subplot(3,3,7)

plt.imshow(markers)
plt.axis("off")
plt.title('Marker')
fig.add_subplot(3,3,8)

plt.imshow(colored_markers)
plt.axis("off")
plt.title('Colored Markers')
fig.add_subplot(3,3,9)

plt.imshow(segmented_image)
plt.axis("off")
plt.title('Segmented Image')
plt.show()

"""Ex No:07		3D Shape From Texture And 3d Object Detection

3D Shape From Texture
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files

def estimate_3d_shape_from_texture(texture_image):
    gray = cv2.cvtColor(texture_image, cv2.COLOR_BGR2GRAY)
    gradient_x = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=5)
    gradient_y = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=5)
    gradient_z = np.ones_like(gradient_x)
    surface_normals = np.dstack((gradient_x, gradient_y, gradient_z))
    surface_normals /= np.linalg.norm(surface_normals, axis=-1, keepdims=True)
    return surface_normals

# Upload an image file
uploaded = files.upload()

# Process the uploaded image
for filename in uploaded.keys():
    # Load the uploaded image
    texture_image = cv2.imread(filename)
    texture_image = cv2.cvtColor(texture_image, cv2.COLOR_BGR2RGB)

    # Estimate 3D shape from the texture image
    estimated_3d_shape = estimate_3d_shape_from_texture(texture_image)

    # Display the original image and estimated 3D shape
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(texture_image)
    plt.axis("off")
    plt.title('Original Image')

    plt.subplot(1, 2, 2)
    plt.imshow(estimated_3d_shape)
    plt.axis("off")
    plt.title('Estimated 3D Shape')

    plt.show()

"""3d Object Detection"""

import cv2
import matplotlib.pyplot as plt
from google.colab import files
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_eye.xml')
uploaded = files.upload()
# Process the uploaded image
for filename in uploaded.keys():
    # Load the uploaded image
    img = cv2.imread(filename)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(gray, 1.3, 5)
    for (x, y, w, h) in faces:
        cv2.rectangle(img, (x, y), (x+w, y+h), (255, 0, 0), 2)
        roi_gray = gray[y:y+h, x:x+w]
        roi_color = img[y:y+h, x:x+w]

        eyes = eye_cascade.detectMultiScale(roi_gray)
        for (ex, ey, ew, eh) in eyes:
            cv2.rectangle(roi_color, (ex, ey), (ex+ew, ey+eh), (0, 255, 0), 2)

    # Display the image with detected face and eyes
    fig = plt.figure(dpi=300)
    fig.add_subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.axis("off")
    plt.title('Face and Eye Detection')
    plt.show()